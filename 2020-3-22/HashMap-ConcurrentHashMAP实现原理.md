## HashMap 与 ConcurrentHashMap 的实现原理

#### HashMap

- 实现Map接口，存储键值对

- 允许有一个null key，多个null value

  > 因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。

- 非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。
- 存储结构：链表加数组。数组中的每个位置被当成一个桶，一个桶存放一个链表。使用拉链法来解决哈希冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。
- 拉链法工作原理（PUT过程）：新建一个HashMap，默认大小为16，插入时，先计算Hashcode为n，除留余数法得到桶下标n%16（table数组长度）。
  若先后两次插入的键值对的‘n%16’值相等，1.7以前使用头插法，后插入的键值对在链表中的位置插在前键值对前面，即链表头部
  头插法容易导致死循环，JDK1.8改用尾插法

>  拉链法又叫链地址法，Java中的HashMap在存储数据的时候就是用的拉链法来实现的，拉链法就是把具有相同散列地址的关键字(同义词)值放在同一个单链表中，称为同义词链表。

- 扩容
  - 如果存储的数据，大于 当前的 HashMap 长度（ Capacity ） * 负载因子（ LoadFactor ，默认为 0.75） 时，就会发生扩容。比如当前容量是 16 ， 16 * 0.75 = 12 ，当存储第 13 个元素时，经过判断发现需要进行扩容，那么这个时候 HashMap 就会先进行扩容的操作
  - Java里的数组是无法自动扩容的，扩容时，首先创建一个新的 Entry 空数组，长度是原数组的 2 倍，扩容完毕之后还会再进行 ReHash ，也就是将原 Entry 数组里面的数据，重新 hash 到新数组里面去
  - 扩容长度一定是2的n次方，源码用位运算代替取模提高效率

> HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。

- 从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树，以减少搜索时间。

> 为什么使用红黑树而非AVL树？
>
> 查找密集型任务使用 AVL 树比较好，相反插入密集型任务，使用红黑树效果就比较好

#### ConcurrentHashMap

- 实现与HashMap类似，但线程安全
- ConcurrentHashMap不允许null key/value 

> 因为无法分辨是key没找到的null还是有key值为null，这在多线程里面是模糊不清的，所以压根就不让put null。

- JDK1.7以前采用了分段锁（核心类Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶。Segment 继承自 可重入锁ReentrantLock。默认的并发级别为 16，并发度就是 Segment 的个数，也就是说默认创建 16 个 Segment。锁粒度：基于 Segment。

-  1.8 版本又做了优化，使用 CAS + synchronized，使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。相比于 ReentrantLock 来说，会节省比较多的内存空间 。 锁粒度：Node（首结点）。锁粒度降低了。
在堆内存中的数据由于可以被任何线程访问到，在没有任何限制的情况下存在被意外修改的风险。

`synchronized`是通过对共享资源加锁的方式，使同一时间只能有一个线程能够访问到临界区（也就是共享资源），共享资源包括了方法、代码块和对象。

> Java中的每个对象都可以作为锁
>
> 1. 普通同步方法，锁是当前实例对象
> 2. 静态同步方法，锁是当前类的class对象
> 3. 同步代码块，锁是括号中的对象

### Synchronized 关键字底层实现

- Synchronized在**Jdk 1.6后**通过对象Mark word实现。会在同步块的前后分别生成 monitorenter 和 monitorexit 字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。Synchronized实现了偏向锁，轻量级锁，重量级锁。 偏向锁是对轻量级锁的优化，轻量级锁是对重量级锁的优化。

>  从JVM规范中可以看到`synchronized`在JVM里的实现原理，JVM基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用 **monitorenter** 和 **monitorexit** 指令实现的，而同步方法中依靠方法修饰符上的 **ACC_SYNCHRONIZED** 实现。
>
>  无论哪种实现，本质上都是对指定对象相关联的monitor的获取，这个过程是互斥性的，也就是说同一时刻只有一个线程能够成功，其它失败的线程会被阻塞，并放入到同步队列中，进入BLOCKED状态。



### 优缺点

synchronized

- 优点：便于JVM堆栈跟踪，**加锁解锁过程由JVM自动控制**
- 缺点：当线程尝试获取锁的时候，如果获取不到锁就会一直阻塞。如果占有锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁会一直等待。

lock

- 优点：**可定时的、可轮询的与可中断的锁获取操作**，提供了读写锁、公平锁和非公平锁
- 缺点：**需手动释放锁unlock**，不适合JVM进行堆栈跟踪



### 与 Lock 相比

**相同点**：都是可重入锁

**不同点**：

- lock是一个接口，而synchronized是java的关键字，synchronized是内置的语言实现；synchronized优化以后性能和lock差不多。

- synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而lock在发生异常时，如果没有主动通过unlock（）去释放锁，则很可能造成死锁现象，因此使用lock（）时需要在finally块中释放锁；

- lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能响应中断

- 通过lock可以知道有没有成功获取锁， lock的功能非常丰富，而synchronized却无法办到。

> 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而竞争资源非常激烈是（既有大量线程同时竞争），此时lock的性能要远远优于synchronized。



### Synchronized执行流程：

- 对象头
  HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

  HotSpot虚拟机的对象头(Object Header)包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。 

- 锁从宏观上分类，分为悲观锁与乐观锁。

  乐观锁
  乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。

  > java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。

  悲观锁
  悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。

------

java中每个对象都可作为锁，锁有四种级别，按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁。并且锁只能升级不能降级。

- 偏向锁

  当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级
  锁的状态。

  > 引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。 
  > 当只有一个线程去竞争锁的时候，我们不需要阻塞，也不需要自旋，因为只有一个线程在竞争，我们只要去判断该偏向锁中的ThreadID是否为当前线程即可。如果是就执行同步代码，不是就尝试使用CAS修改ThreadID，修改成功执行同步代码，不成功就将偏向锁升级成轻量锁。

  > 优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。
  >
  > 偏向锁可以通过虚拟机的参数来控制它是否开启。

- 自旋锁

  背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。

  原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。

- 轻量级锁

  本质：使用CAS取代互斥同步。

  实现原理：  

  - 对象头称为『Mark Word』，虚拟机为了节约对象的存储空间，对象处于不同的状态下，Mark Word中存储的信息也所有不同。
  - Mark Word中有个标志位用来表示当前对象所处的状态。
  - 当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；
  - 若CAS操作成功，则轻量级锁的上锁过程成功；
  - 若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。

> 轻量级锁与重量级锁的比较：  
>
> - 重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全；
> - 而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。

- 重量级锁

  互斥锁(重量级锁)也称为阻塞同步、悲观锁

  重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也称为互斥锁

  为什么重量级线程开销很大？

  当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的。
  

![https://upload-images.jianshu.io/upload_images/4491294-345a15342fad119a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1186/format/webp]()

![https://upload-images.jianshu.io/upload_images/4491294-e3bcefb2bacea224.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp]()

> https://blog.csdn.net/bingxuesiyang/article/details/89332989?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328655.11204.16158827246358521&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control
## volatile的作用

- 在并发编程中保证了共享变量的可见性。(可见性:当一个线程修改了一个共享变量，另外一个线程可以立即读到这个修改的值。)

>  线程对变量的所有操作都必须在线程自己的工作内存中完成，而不能直接读取主存中的变量，这是JMM的规定。所以每个线程都会有自己的工作内存，工作内存中存放了共享变量的副本。而正是因为这样，才造成了可见性的问题。
>
>  如果volatile使用恰当的话，它比Synchronized的使用成本和执行成本更低，因为它不会引入线程上下文切换的额外调度。
>

## volatile的特性
- 可见性：对一个volatile变量的读，总是能看到对这个volatile变量最后的写入
- 原子性：对任意单个volatile变量的读/写具有原子性


## volatile写读的内存语义

- 写：当写一个volatile变量时，JMM（JAVA MEMORY MODEL）会把该线程对应的本地内存中的共享变量值刷新到主内存。

- 读：当读一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量置为无效。线程接下来会从竹内中读取共享变量

## volatile内存语义的实现原理
- 禁止指令重排序，涉及读写屏障。


JMM针对volatile分别对编译器重排序与处理器重排序进行了限制。为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

> 在每个volatile写操作前面插入一个StoreStore屏障
>
> 在每个volatile写操作后面插入一个StoreLoad屏障
>
> 在每个volatile读操作前面插入一个LoadLoad屏障
>
> 在每个volatile读操作后面插入一个LoadStore屏障
>
> https://www.siques.cn/doc/542
#### Java 中垃圾回收机制中如何判断对象需要回收？

- 引用计数法（RC）
  - 在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。
  - 实现简单，判定效率高，但主流的 Java 虚拟机没有选用引用计数算法管理内存，因为它很难解决对象之间循环引用的问题。
  - 举例 对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。
- 可达性分析法（Root Searching）
  - 所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。
  - GC Roots 是指：
    - Java 虚拟机栈（栈帧中的本地变量表）中引用的对象
    - 本地方法栈中引用的对象
    - 方法区中常量引用的对象
    - 方法区中类静态属性引用的对象
  - GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。

#### 常见的 GC 回收算法有哪些？

- 标记-清除算法
  - 标记的过程是：遍历所有的 GC Roots，然后将所有 GC Roots 可达的对象标记为存活的对象。
  - 清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。
  - 这种方法有两个不足：
    - 效率问题：标记和清除两个过程的效率都不高。
    - 空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

- 复制算法（新生代）
  - 为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。
  - 优点
    - 不会有内存碎片的问题。
  - 缺点
    - 内存缩小为原来的一半，浪费空间。
- 为了解决空间利用率问题，可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保。

- 标记-整理算法（老年代）
  - 标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历 GC Roots，然后将存活的对象标记。
  - 整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。
  - 这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。

- 分代收集算法
  - 根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。
    - 新生代：复制算法
    - 老年代：标记-清除算法、标记-整理算法

#### JVM 中内存模型是怎样的？哪些区域是线程安全的？

Java 虚拟机的内存空间分为 5 个部分：

- 程序计数器
- Java 虚拟机栈
- 本地方法栈
- 堆
- 方法区
  - JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。
- 总结
  		每个线程有自己的程序计数器（PC），Java虚拟机栈（VMS），本地方法栈（NMS）。它们共享堆和方法区（1.8之前是Perm Space，1.8及以后是Meta Space）。
- 线程私有（程序计数器、java虚拟机栈、C栈**线程安全**，随线程销毁而销毁），线程共享（堆、元数据区（方法区）**线程不安全**）

#### 简述新生代与老年代的区别？如何确定eden区的对象何时进入老年代？

当对象刚创建的时候，是处于eden区的，经过一次垃圾回收之后进入survivor区，再经过一次垃圾回收之后进入第二个survivor区，当年龄够了或者survivor放不下的时候就会进入tenured区。年龄对应的虚拟机参数为**-XX:MaxTenuringThreshold** 

#### Java 类的加载流程是怎样的？

​	从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：**加载，验证，准备，解析，初始化，使用，卸载**。其中**验证，准备，解析**三个部分统称为**连接**。

- 加载
  -  将class文件加载到内存
  -  将静态数据结构转化成方法区中运行时的数据结构
  -  在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口
- 连接
  -  验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查
  -  准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）
  - 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）
- 初始化
  - 初始化其实就是一个赋值的操作，它会执行一个类构造器的<clinit>()方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为3

#### 什么是双亲委派机制？

- 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。
- 比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载
- 这样做的好处是，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。避免了我们的代码影响JDK的代码。

#### Java 编译后的 .class 文件包含了什么内容？

Class 文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全都是连续的 0/1。Class 文件 中的所有内容被分为两种类型：无符号数、表。

- 无符号数 表示 Class 文件中的值，这些值没有任何类型，但有不同的长度。u1、u2、u4、u8 分别代表 1/2/4/8 字节的无符号数。
- 表 由多个无符号数或者其他表作为数据项构成的复合数据类型。

Class 文件具体由以下几个构成:

- 魔数 MagicNumber Class 文件的头 4 个字节称为魔数，用来表示这个 Class 文件的类型。Class 文件的魔数是用 16 进制表示的“CAFE BABE”。

> （魔数相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在 Class 文件中标识文件类型比较合适。）

- 版本信息
  紧接着魔数的 4 个字节是版本信息，5-6 字节表示次版本号，7-8 字节表示主版本号，它们表示当前 Class 文件中使用的是哪个版本的 JDK。高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必需拒绝执行超过其版本号的 Class 文件。
- 常量池  ConstantPool  版本信息之后就是常量池，常量池中存放两种类型的常量：
  - 字面值常量  
    - 字面值常量就是我们在程序中定义的字符串、被 final 修饰的值。
  - 符号引用
    - 符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。
  - 常量池的特点
    - 常量池中常量数量不固定，因此常量池开头放置一个 u2 类型的无符号数，用来存储当前常量池的容量。
    - 常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型
- 访问标志   AccessFlags 
  - 在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final 修饰。
- 类索引、父类索引、接口索引集合
- 字段表集合  Fields
- 方法表集合  Methods
- 属性表集合

#### 简述标记清除算法的流程

标记-清除算法

- 标记的过程是：遍历所有的 GC Roots，然后将所有 GC Roots 可达的对象标记为存活的对象。
- 清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。
- 这种方法有两个不足：
  - 效率问题：标记和清除两个过程的效率都不高。
  - 空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

- 另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块，将分块连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

- 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

#### 简述G1收集器原理

- G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离，G1 可以直接对新生代和老年代一起回收。

- 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

- 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。（没懂）
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。



#### 简述 Java 的逃逸分析机制

> 什么是逃逸？
>
> **方法逃逸**：当一个对象在方法里面被定义之后，他可能会被外部方法所引用，例如作为参数传递到其他方法，也及对象逃离了方法的作用范围，这种行为被称为方法逃逸。
>
> **线程逃逸**：当被定义的对象赋值给可以被其他线程所访问的对象时，被称为线程逃逸。
>
> > 从不逃逸到方法逃逸直至线程逃逸的过程，称为对象由低到高的不同逃逸程度。

逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域，使用逃逸分析，编译器可以对代码做如下优化：

### **栈上分配**

众所周知，Java在堆中分配创建对象的内存空间。Java堆中的对象是线程共享的，也就是说，只要持有某个对象的引用，就可以访问到堆中的对象。虚拟机的垃圾回收器会回收不再使用的对象，但无论是筛选出不再使用的对象还是回收和整理内存，都是非常耗费资源的。如果确定一个对象不会存在线程逃逸的问题，例如局部对象等所占的比例是非常大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾回收的压力也将大大减轻。

然而，这项优化仍在进行中。

> 将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

### 标量替换

若一个数据已经无法再分解成更小的数据来表示，例如Java虚拟机中的原始数据类型都不能再进一步分解了，那么这些数据就可以称为**标量**。如果一个数据类型可以被进一步分解，例如对象，那它就被称为**聚合量**。

如果把一个对象拆散，根据程序访问的情况，将其用到的成员变量恢复到原始类型来访问，这个过程称为标量替换。

假如逃逸分析证明一个对象确实不会逃离方法的作用范围，并且这个对象可以被进一步分解，那么该对象可能在程序执行时不会被创建，而创建若干个被该方法使用的成员变量来代替。

> 分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

### 同步消除

线程同步本身是一个相对耗时的过程，如果对一个变量进行逃逸分析确定不会逃出方法的作用范围，那么该变量一定不会出现线程安全问题，那么也就不需要对这个变量实施同步措施。

> 同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

## 最后

逃逸分析这项技术至今尚未成熟，不成熟的原因主要是由于其计算成本太高，试想如果花费了大力气去寻找逃逸对象，而分析完毕后几乎找不到几个不逃逸的对象，那么这些运行期间耗费的资源就白白浪费了，因此虚拟机现在采用的的逃逸分析算法不那么准确，但时间压力相对较小。

#### 如何优化 JVM 频繁 minor GC

MinorGC/YGC：年轻代空间耗尽时触发

- Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。
- 单次**Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小**

如何选择各分区大小应该依赖应用程序中**对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。**



#### (待完善)JVM 内存是如何对应到操作系统内存的？

#### JVM 是怎么去调优的？简述过程和调优的结果

- 根据需求进行JVM规划和预调优
-  优化运行JVM运行环境
-  解决JVM运行过程中出现的各种问题（OOM）

CPU高 -> Top，JPS （查看哪个进程出问题） -> jstack（看哪个线程） -> 如果是频繁GC，就用jmap导出来看

#### Java 怎么防止内存溢出

高可用 、压力测试、监控（arthas）、预调优 （指定各区域内存大小，选择合适的垃圾回收器）、OOM时，Dump出堆

根据系统情况、经预估后显示指定堆内新生代老年代大小，元空间大小。

- Sun官方推荐配置为java堆的比例为3/8，Eden和Survivor的占比为8:1:1

- 永久代一般为初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）
  - 将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

- 在OOM时，记得Dump出堆，确保可以排查现场问题，通过先别重启，用jmap - dump:format=b,file=xxx pid / jmap -histo命令输出一个.dump文件，使用VisualVM工具。

- 监控GC活动

#### 什么是内存泄漏，怎么确定内存泄漏？

计算机科学中，内存泄漏(memory leak)指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序**分配某段内存后，由于设计错误，失去了对该段内存的控制**，因而造成了内存的浪费。

#### 什么是堆内存异常？

java.lang.OutOfMemoryError: Java heap space：java堆内存不够

**OutOfMemoryError** 异常的常见原因：

1. 加载的数据过大。如：加载的文件或者图片过大、一次从数据库取出过多数据
2. 代码存在死循环或循环产生过多的对象

**解决方法**

1. 增加jvm的内存大小，使用 -Xmx 和 -Xms 来设置
2. 检查代码中是否有死循环或递归调用。
3. 检查是否有大循环重复产生新对象实体。
4. 检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
5. 检查List、Map等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

